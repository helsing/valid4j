Concepts

  Programming by contract is a simple, yet powerful, technique to achieve assertive programming.
  The basic idea of valid4j is to make a clear distinction between <programming errors> and 
  <recoverable exceptions>. 
  
* Programming errors

  Programming errors are usually the result of an oversight of assumptions that really doesn't hold.
  This may result in logical contradictions, like trying to use a non-existent object (eg NullPointerException) 
  or invoking a method with an argument that (eg IllegalArgumentException).
  These are logical errors that should be avoided already at design time. It doesn't make sense
  to <<<try>>> these invocations in order to <<<catch>>> and recover from them. Programming errors
  need to be corrected in the code at design time.
  
  Needless to say, these kind of logical errors will still occur from time to time in a normally buggy 
  program. Programming by contract gives us a technique to detect, expose, find and finally resolve bugs
  in our programs.
  
* Recoverable exceptions

  Recoverable exceptions, on the other hand, signal exceptional cases that a correct program can and
  should handle gracefully. This might be network connection errors, file system errors or data input
  validation errors. This is what we in everyday talk refers to as error handling, fault tolerance and the like.
  
  According to the Java exception hierarchy, as a general rule programming errors should inherit from 
  <<<RuntimeException>>> whereas <<<Error>>> is reserved for internal errors of the Java runtime system.
  
  However, there is also lots of differing opinions regarding the proper use of checked vs unchecked exceptions.
  This has led to the widespread use of <<<RuntimeException>>> also for recoverable exceptions.
  
  Valid4J prefers to use <<<Error>>> to signal programming errors, and is agnostic to the question of
  checked vs unchecked recoverable exceptions.

Defensive programming

  ...a common, but sad example... 
  
-------------------------------------
// Example of client code with sad defensive programming
Object someParam;
...
Stuff result = supplier.method(someParam);
if (result == null) {
  // Some error handling
} else if (supplier.getState() == GREAT) {
  result.doWork();
} else {
  // Some more error handling
}

-------------------------------------
-------------------------------------
// Example of supplier code with sad defensive programming
public Stuff method(Object param) {
  Stuff r;
  if (param == null) {
    // Some error handling
  } else if (getState() == GOOD) {
    r = a.doStuff();
  } else {
    // Even more error handling
  }
  return r;
-------------------------------------

  The characteristic of the above code is that no one knows their responsibilities. No one 
  knows what they are supposed to do or what others are supposed to do. Code is recognized 
  by "maybe"/"perhaps"/"if you're lucky" statements, obscuring the real semantics
  and valid error handling. Are there any programming errors hidden in this code? How do I
  know? Defensive programming hides programming errors in a bloat of code and - which is worse - 
  are handled as ordinary recoverable errors! Programming errors should not be dealt with this way.
  Fail fast, don't let bugs go undetected.

Design by Contract and assertive programming

  Using contracts we can clarify the responsibilities between the calling side (client) and 
  the called side (supplier). Contracts explicitly state what are your obligations and what are my 
  obligations? A contract violation implies a logical error in the program. Therefore it doesn't
  make sense to try to recover from it. If you do, you're doing it wrong...

  If a bug is detected in your application, it means it is in an unknown state, a state 
  that your code is not prepared to handle. A reasonable <global> recovery policy would perhaps
  be to restart your application, return a HTTP 500 response or similar.

Good manners to keep

  If you are using contracts to clarify the responsibilities between clients and suppliers there are
  a couple of things to keep in mind.
  First, separate commands from queries. Your methods should have single well-defined responsibilities.
  Either they are commands, methods that change the current state. Or they are queries, side-effect free 
  methods that return a result.
  
  Separate commands from queries! Only use queries when specifying contracts == never use commands in contracts!
  The client shall always have the possibility to check the preconditions...
  
Don't use contracts for error handling. Don't use error handling for contracts.

  Example country codes? Error handling at system boundaries. Never catch and try to recover from contract 
  violations - you're doing it wrong if you do. Instead use the uncaughtExceptionHandler for global recovery.
  
Invariants

  Dragons be here...
  
Contracts and inheritence

  LSP. Preconditions may be weakened for subclasses. Postconditions may be strengthened for subclasses. 
  (it's not as easy as to say that contracts can simply be inherited by subclasses)
  
Contracts and multi-threading

  You can't put contracts on conditions that are outside your thread of control. Those conditions need to be dealt with using regular error handling, eg throw a recoverable exception.
  
Contracts and unit testing

  Contracts and unit testing complement each other. Leave the assertions on in production.
  
Alternatives

  Google Guava, commons-lang Validate and Objects.requireNotNull.
  
One-liners

  Contracts help us detect, expose, find and fix bugs!

  * Separate queries from commands
  
  * Only use side-effect free query methods when specifying contracts
  
  * Always make it possible for your clients to live up to their obligations (no hidden requires)
  
  * Do not try to catch and recover from contract violations (only at the top level is it relevant)
  
  []
    
===
  
References

  * {{{https://en.wikipedia.org/wiki/Design_by_Contract}Wikipedia, Design by Contract}}.
  
  * {{{http://www.academia.edu/4903777/Object-Oriented_Software_Construction_SECOND_EDITION}Object-Oriented Software Construction, Chapter 11, Design by Contract}}.
  
  * The Pragmatic Programmer, Chapter 4, Design by Contract & Assertive Programming.
  
  * Google.
  
  []

